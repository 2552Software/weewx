#!/usr/bin/env python
#
#    Copyright (c) 2009-2016 Tom Keffer <tkeffer@gmail.com> and
#                            Gary Roderick
#
#    See the file LICENSE.txt for your rights.
#
"""Import weewx observation data from an external source.

Compatibility:

   wee_import can import from a Comma Separated Values (CSV) format file,
   directly from the historical records of a Weather Underground Personal
   Weather Station or from one or more Cumulus monthly log files. CSV format
   files must have a comma separated list of field names on the first line.

Design

   wee_import utilises a number of command line parameters/options to control
   its basic functions. A wee_import config file (default name wee_import.conf)
   is used to configure more advanced options such as field maps etc. Details
   of the supported command line parameters/options can be viewed by entering
   wee_import --help at the command line. Details of the wee_import config file
   settings can be found in wee_import.conf.

   wee_import utilises an abstract base class that defines the majority of the
   wee_import functionality. Child classes are created from the base class for
   each different import type supported by wee_import. The child classes set a
   number of import type specific properties as well as defining a getData()
   method that reads the raw data to be imported and a period_generator()
   method that generates a sequence of objects to be imported (eg monthly log
   files). This way wee_import can be extended to support other sources by
   defining a new child class, its specific properties as well as getData() and
   period_generator() methods.

   As with other weewx utilities, wee_import advises the user of basic
   configuration, action taken and results via stdout. However, since
   wee_import can make substantial changes to the weewx archive, wee_import also
   logs to same log as used by weewx (the default) using the syslog service.
   This function can be controlled via a command line option.

Prerequisites

   wee_import uses a number of weewx API calls and therefore must have a
   functional weewx installation. wee_import requires weewx 3.6.0 or later.

Configuration

   A number of parameters can be defined in the wee_import config file as
   follows:

[CSV]
    # Parameters used when importing from a CSV file

    # If there is no mapped interval field how will the interval field be
    # determined for the imported records. Available options are:
    #   derive - Derive the interval field from the timestamp of successive
    #            records. This setting is best used when the imported records
    #            are equally spaced in time and there are no missing records.
    #   conf   - Use the interval setting from weewx.conf. This setting is
    #            best used if the records to be imported have been produced by
    #            weewx using the same archive interval as set in weewx.conf on
    #            this machine.
    #   xx     - Use a fixed interval of xx minutes for every record. This
    #            setting is best used if the records to be imported are
    #            equally based in time but there are some missing records.
    #            This setting is recommended for WU imports.
    #
    # Note: If there is a mapped interval field then this setting will be
    #       ignored.
    interval = derive

    # Imported records are written to archive in transactions of tranche
    # records at a time. Increase for faster throughput, decrease to reduce
    # memory requirements.
    tranche = 250

    # Date-time format of CSV field from which the weewx archive record
    # dateTime field is to be extracted. wee_import first attempts to interpret
    # date/time info in this format, if this fails it then attempts to
    # interpret it as a timestamp and if this fails it then raises an error.
    # Uses Python strptime() format codes.
    raw_datetime_format = %Y-%m-%d %H:%M:%S

    # What does the imported rain field represent, is it the total rainfall
    # since the last record or a cumulative daily value. Available options
    # are:
    #   discrete   - rain field represents total rainfall since last record
    #   cumulative - rain field represents a cumulative daily rainfall reset
    #                at midnight
    rain = cumulative

    # Lower and upper bounds for imported wind direction. Format is:
    #
    # wind_direction = lower,upper
    #
    # where :
    #   lower is the lower limit of acceptable wind direction in degrees
    #   (may be negative)
    #   upper is the upper limit of acceptable wind direction in degrees
    #
    # It is possible, particularly for a calculated direction, to have a value
    # (eg -45) outside of the weewx limits (0 to 360 inclusive). Imported
    # values from lower to upper will be normalised to the range 0 to 360.
    # Values outside of the parameter range will be stored as None. Default
    # is 0,360
    wind_direction = 0,360

    # Map CSV record fields to weewx archive fields. Format is:
    #
    #   weewx_archive_field_name = csv_field_name, weewx_unit_name
    #
    # where:
    #   weewx_archive_field_name is an observation name in the weewx database
    #   schema.
    #   csv_field_name is the name of a field from the CSV file.
    #   weewx_unit_name is the name of the units, as defined in weewx, used by
    #   csv_field_name. This value represents the units used for this field in
    #   the CSV file, wee_import will do the necessary conversions to the unit
    #   system used by the weewx archive.
    #
    # For example,
    #   dewpoint = dew, degree_C
    # would map the CSV field dew, in degrees C, to the archive field dewpoint
    #
    # Archive fields that do not exist in the CSV data may be omitted. Any
    # omitted fields that are derived (eg dewpoint) may be calculated during
    # import using the equivalent of the weewx StdWXCalculate service through
    # use of the --calc-missing command line parameter.
    [[Map]]
        dateTime    = timestamp, unix_epoch
        usUnits     =
        interval    =
        barometer   = barometer, inHg
        pressure    =
        altimeter   =
        inTemp      =
        outTemp     = Temp, degree_F
        inHumidity  =
        outHumidity = humidity, percent
        windSpeed   = windspeed, mile_per_hour
        windDir     = wind, degree_compass
        windGust    = gust, mile_per_hour
        windGustDir = gustDir, degree_compass
        rainRate    = rate, inch_per_hour
        rain        = dayrain, inch
        dewpoint    =
        windchill   =
        heatindex   =
        ET          =
        radiation   =
        UV          =

[Wunderground]
    # Parameters used when importing from a WU PWS
    #
    # When importing WU data the following weewx database fields will be
    # populated directly by the imported data (provided the corresponding data
    # exists on WU):
    #   barometer
    #   dateTime
    #   dewpoint
    #   outHumidity
    #   outTemp
    #   radiation
    #   rain
    #   windDir
    #   windGust
    #   windSpeed
    #
    # The following weewx database fields will be populated from other
    # settings/config files:
    #   interval
    #   usUnits
    #
    # The following weewx database fields will be populated with values derived
    # from the imported data provided the --calc-missing command line option is
    # used during import:
    #   altimeter
    #   ET
    #   heatindex
    #   pressure
    #   rainRate
    #   windchill
    #
    # The following weewx fields will be populated with derived values from the
    # imported data provided the --calc-missing command line option is used
    # during import. These fields will only be saved to the weewx database if
    # the weewx schema has been modified to accept them. Note that the pyephem
    # module is required in order to calculate maxSolarRad - refer weewx Users
    # Guide.
    #   appTemp
    #   cloudbase
    #   humidex
    #   maxSolarRad
    #   windrun

    # How will the interval field be determined for the imported records.
    # Available options are:
    #   derive - Derive the interval field from the timestamp of successive
    #            records. This setting is best used when the imported records
    #            are equally spaced in time and there are no missing records.
    #   conf   - Use the interval setting from weewx.conf. This setting is
    #            best used if the records to be imported have been produced by
    #            weewx using the same archive interval as set in weewx.conf on
    #            this machine.
    #   xx     - Use a fixed interval of xx minutes for every record. This
    #            setting is best used if the records to be imported are
    #            equally based in time but there are some missing records.
    # Due to WU frequently missing uploaded records, use of 'derive' may give
    # incorrect or inconsistent interval values. Better results may be
    # achieved by using the 'conf' setting (if weewx has been doing the WU
    # uploading) or setting the interval to a fixed value (eg 5). The most
    # appropriate setting will depend on the completeness and (time) accuracy
    # of the WU data being imported.
    interval = 5

    # Imported records are written to archive in in transactions of tranche
    # records at a time. Increase for faster throughput, decrease to reduce
    # memory requirements.
    tranche = 250

    # Lower and upper bounds for imported wind direction. Format is:
    #
    # wind_direction = lower,upper
    #
    # where :
    #   lower is the lower limit of acceptable wind direction in degrees
    #   (may be negative)
    #   upper is the upper limit of acceptable wind direction in degrees
    #
    # WU has at times been known to store large values (eg -9999) for wind
    # direction, often no wind direction was uploaded to WU. The wind_direction
    # parameter sets a lower and upper bound for valid wind direction values.
    # Values inside these bounds are normalised to the range 0 to 360. Values
    # outside of the bounds will be stored as None. Default is 0,360
    wind_direction = 0,360

[Cumulus]
    # Parameters used when importing Cumulus monthly log files
    #
    # When importing Cumulus monthly log file data the following weewx database
    # fields will be populated directly by the imported data:
    #   barometer
    #   dateTime
    #   dewpoint
    #   heatindex
    #   inHumidity
    #   inTemp
    #   outHumidity
    #   outTemp
    #   radiation   (if Cumulus data available)
    #   rain        (requires Cumulus 1.9.4 or later)
    #   rainRate
    #   UV          (if Cumulus data available)
    #   windDir
    #   windGust
    #   windSpeed
    #   windchill
    #
    # The following weewx database fields will be populated from other
    # settings/config files:
    #   interval
    #   usUnits
    #
    # The following weewx database fields will be populated with values derived
    # from the imported data provided the --calc-missing command line option is
    # used during import:
    #   altimeter
    #   ET
    #   pressure
    #
    # The following weewx fields will be populated with derived values from the
    # imported data provided the --calc-missing command line option is used
    # during import. These fields will only be saved to the weewx database if
    # the weewx schema has been modified to accept them. Note that the pyephem
    # module is required in order to calculate maxSolarRad - refer weewx Users
    # Guide.
    #   appTemp
    #   cloudbase
    #   humidex
    #   maxSolarRad
    #   windrun

    # How will the interval field be determined for the imported records.
    # Available options are:
    #   derive - Derive the interval field from the timestamp of successive
    #            records. This setting is best used when the imported records
    #            are equally spaced in time and there are no missing records.
    #   conf   - Use the interval setting from weewx.conf. This setting is
    #            best used if the records to be imported have been produced by
    #            weewx using the same archive interval as set in weewx.conf on
    #            this machine.
    #   xx     - Use a fixed interval of xx minutes for every record. This
    #            setting is best used if the records to be imported are
    #            equally based in time but there are some missing records.
    # To import Cumulus records it is recommended that the interval setting
    # be set to the value used in Cumulus as the 'data log interval'.
    interval = 10

    # Cumulus monthly log files may not always use a comma to delimit fields in
    # the monthly log files. Specify the character used as the field delimiter.
    # The character should be enclosed in quotes. Must not be the same as the
    # decimal setting.
    #
    # For example,
    #   delimiter = ','
    # would use the comma as the field delimiter
    delimiter = ','

    # Cumulus monthly log files may not always use a fullstop character as
    # the decimal point. Specify the character used as the decimal point. The
    # character should be enclosed in quotes. Must not be the same as the
    # delimiter setting.
    #
    # For example,
    #   decimal = '.'
    # would use the full stop as the decimal point
    decimal = '.'

    # Imported records are written to archive in in transactions of tranche
    # records at a time. Increase for faster throughput, decrease to reduce
    # memory requirements.
    tranche = 250

    # The units used for temperature, pressure, rain and windspeed related
    # observations in the Cumulus monthly logs are set at the Cumulus
    # Station Configuration Screen. For correct import of the monthly logs
    # wee_import needs to know what units are used in the imported data. The
    # [[Units]] settings should be set to the weewx equivalent of the units
    # of measure used by Cumulus (eg if Cumulus used 'C' for temperature
    # temperature should be set to 'degree_C'). Note that Cumulus does not
    # support all units used by weewx (eg 'mmHg') so not all weewx unit are
    # available options.
    [[Units]]
        temperature = degree_C      # options are 'degree_F' or 'degree_C'
        pressure    = hPa           # options are 'inHg', 'mbar' or 'hPa'
        rain        = mm            # options are 'inch' or 'mm'
        speed       = km_per_hour   # options are 'mile_per_hour',
                                    # 'km_per_hour', 'knot' or
                                    # 'meter_per_second'

Adding a New Import Source

    To add a new import source:

    -   Add a new 'verb' to the wee_import usage and option parser in main()
        eg

        wee_import --new_source_name

    -   Add the new 'verb' to dest_list

    -   Define a new class for the source that is a child of class Source. The
        new class must meet the following minimum requirements:

        -   __init__() must define:

            -   self.raw_datetime_format: Format of date time data field from
                                          which observation timestamp is to be
                                          derived. String comprising Python
                                          strptime() format codes.
            -   self.rain: Whether imported rainfall field contains the
                           rainfall since the last record or a cumulative value.
                           String 'discrete' or 'cumulative'
            -   self.wind_dir: The range of values in degrees that will be
                               accepted as a valid wind direction. Two way
                               tuple of the format (lower, upper) where lower
                               is the lower inclusive limit and upper is the
                               upper inclusive limit.

        -   Define a period_generator() method that:

            -   Accepts no parameters and generates (yields) a sequence of
                objects (eg file names, dates for a http request etc) that are
                passed to the getRawData() method to obtain a sequence of raw
                data records.

        -   Define a getRawdata() method that:

            -   Accepts a single parameter 'period' that is provided by the
                period_generator() method

            -   Returns an iterable of raw source data records.

            -   Creates the source data field-to-weewx archive field map and
                saves the map to the class object map property (the map may be
                created using the Source.parseMap() method). Refer to
                getRawData() methods in CSVSource and WunderSource classes.

    -   Modify the Source.sourcefactory() method to create an instance of the
        new class when required.
"""

from __future__ import with_statement

# standard python imports
import csv
import datetime
import glob
import optparse
import os.path
import re
import sys
import syslog
import time
import urllib2

from datetime import datetime as dt
from distutils.version import StrictVersion

# weewx imports
import weecfg
import weewx
import weewx.wxservices

from weewx.manager import open_manager_with_config
from weewx.units import unit_nicknames, convertStd, to_std_system, ValueTuple
from weeutil.weeutil import TimeSpan, timestamp_to_string, startOfDay, option_as_list, to_int

# wee_import version number
WEE_IMPORT_VERSION = '0.1'
# minimum weewx version required for this version of wee_import
# FIX ME - need to change to 3.6.0 before release
REQUIRED_WEEWX = "3.5.0"

# Minimum requirements in any explicit or implicit weewx field-to-import field
# map
MINIMUM_MAP = {'dateTime': {'units': 'unix_epoch'},
               'usUnits': {'units': None},
               'interval': {'units': 'minute'}}

# List of 'dest' settings used by our 'verbs', note 'dest' may be explicit or
# implicit. If adding more 'verbs' need to add corresponding 'dest' here.
dest_list = ['csv', 'wunder', 'cumulus', 'version']

# Dict to lookup rainRate units given rain units
rain_units_dict = {'inch': 'inch_per_hour', 'mm': 'mm_per_hour'}

# Instance of our logger
wlog = None

description = """Import observation data into a weewx archive."""

usage = """wee_import --help
       wee_import --csv
            [--config=CONFIG_FILE]
            [--import-config=IMPORT_CONFIG_FILE]
            --source=CSV_SOURCE_FILE
            [--date YYYY/MM/DD|YYYY/MM/DD hh:mm-YYYY/MM/DD hh:mm]
            [--calc-missing] [--dry-run]
            [--log=None|LOG_FACILITY] [--verbose]
       wee_import --wunder
            [--config=CONFIG_FILE]
            [--import-config=IMPORT_CONFIG_FILE]
            --station=PWS_NAME
            [--date YYYY/MM/DD|YYYY/MM/DD hh:mm-YYYY/MM/DD hh:mm]
            [--calc-missing] [--dry-run]
            [--log=None|LOG_FACILITY] [--verbose]
       wee_import --cumulus
            [--config=CONFIG_FILE]
            [--import-config=IMPORT_CONFIG_FILE]
            --source=MONTHLY_LOGS_FOLDER
            [--date YYYY/MM/DD|YYYY/MM/DD hh:mm-YYYY/MM/DD hh:mm]
            [--calc-missing] [--dry-run]
            [--log=None|LOG_FACILITY] [--verbose]
       wee_import --version
"""

epilog = """wee_import will import data from an external source into a weewx
            archive. Daily summaries are updated as each archive record is
            imported so there should be no need to separately drop and rebuild
            the daily summaries using the wee_database utility."""


def main():
    """The main routine that kicks everthing off."""

    global wlog

    # Create a command line parser:
    parser = optparse.OptionParser(description=description,
                                   usage=usage,
                                   epilog=epilog)

    # Add the various options:
    parser.add_option("--config", dest="config_path", type=str,
                      metavar="CONFIG_FILE", default='weewx.conf',
                      help="Use configuration file CONFIG_FILE.")
    parser.add_option("--import-config", dest="import_config_path", type=str,
                      metavar="IMPORT_CONFIG_FILE", default='wee_import.conf',
                      help="Use configuration file CONFIG_FILE.")
    parser.add_option("--csv", dest="csv", action='store_true',
                      help="Obtain data from a csv format text file specified"
                           " using the --source option.")
    parser.add_option("--wunder", dest="wunder", action='store_true',
                      help="Obtain data from a Weather Underground PWS.")
    parser.add_option("--cumulus", dest="cumulus", action='store_true',
                      help="Obtain data from Cumulus monthly report files in the"
                           "folder specified using the --source option.")
    parser.add_option("--import", dest="import_data", action='store_true',
                      help="Save any imported data to the weewx archive.")
    parser.add_option('--source', dest='source', type=str, metavar="SOURCE",
                      help="Name of source file or folder to be used. Include "
                           " path if a file (eg /home/weewx/data.csv).")
    parser.add_option("--calc-missing", dest="calc_missing", action='store_true',
                      help="Attempt to calculate any missing derived observations"
                           " such as windchill, heatindex etc.")
    parser.add_option('--dry-run', dest='dry_run', action='store_true',
                      help='Print what would happen but do not do it.')
    parser.add_option('--station', dest='station', type=str,
                      metavar="PWS_NAME",
                      help="Station name to be used (eg, \"KORHOODR3\").")
    parser.add_option("--date", dest="date", type=str, metavar="YYYY-MM-DD",
                      help="Date to import as a string of form \"YYYY-MM-DD\" "
                           "or a date range of form \"YYYY-MM-DD hh:mm-"
                           "YYYY-MM-DD hh:mm\"")
    parser.add_option('--log', dest='logging', type=str,
                      metavar="LOG_FACILITY", default='weewx',
                      help="Control logging of most output. If omitted or "
                           "LOG_FACILITY is 'weewx' then logs are written to the "
                           "same log used by weewx. If LOG_FACILITY is 'syslog' "
                           "then logs are written to syslog. Logging is turned "
                           "off if LOG_FACILITY is None.")
    parser.add_option("--verbose", action="store_true", dest="verbose",
                      help="Print useful extra output.")
    parser.add_option('--version', dest='version', action='store_true',
                      help='Display wee_import version number.')

    # Now we are ready to parse the command line:
    (options, args) = parser.parse_args()

    # Do a check to see if the user used more than 1 'verb' . More than 1 verb
    # should be avoided - what did the user really want to do?
    # first get a list of options actually used
    options_list = [opt for opt, val in options.__dict__.items() if val is not None]
    # now a list of the 'dest' settings used
    dest_used = [opt for opt in options_list if opt in dest_list]
    # If we have more than 1 entry in dest_used then we have more than 1 'verb'
    # used. Then inform the user and exit. If only 1 'verb' then carry on.
    if len(dest_used) > 1:
        # generate the message but we need to speak 'options' (aka verbs)
        # not 'dest'
        # get a dict of {option.dest: option.str} from our universe of options
        opt_dict = dict((x.dest, x.get_opt_string()) for x in parser.option_list[1:])
        # now get a list of 'verbs' used
        verbs_used = [opt_dict[x] for x in dest_used]
        # get rid of the [ and ]
        verbs_str = ', '.join(verbs_used)
        # our exit message
        exit_str = ("Multiple verbs found in command line %s. Only one verb permitted.\nNothing done, exiting." %
                    (verbs_str,))
        # now exit with our message
        exit(exit_str)

    # check weewx version number for compatibility
    if StrictVersion(weewx.__version__) < StrictVersion(REQUIRED_WEEWX):
        print "weewx %s or greater is required, found %s. Nothing done, exiting." % (REQUIRED_WEEWX,
                                                                                     weewx.__version__)
        exit(1)

    # Set up our syslog
    wlog = WeeImportLog(options.logging, options.verbose, options.dry_run)

    # display wee_import version info
    if options.version:
        print "wee_import version: %s" % WEE_IMPORT_VERSION
        exit(0)

    # If we got this far we must want to import something so get a Source
    # object from our factory and try to import. Be prepared to catch any
    # errors though.
    try:
        source_obj = Source.sourceFactory(options, args)
        source_obj.run()
    except WeeImportIOError, e:
        wlog.printlog(syslog.LOG_INFO, "**** Unable to load source file.")
        wlog.printlog(syslog.LOG_INFO, "**** %s" % e)
        print "**** Nothing done, exiting."
        wlog.logonly(syslog.LOG_INFO, "**** Nothing done.")
        exit(1)
    except WeeImportFieldError, e:
        wlog.printlog(syslog.LOG_INFO, "**** Unable to map source data.")
        wlog.printlog(syslog.LOG_INFO, "**** %s" % e)
        print "**** Nothing done, exiting."
        wlog.logonly(syslog.LOG_INFO, "**** Nothing done.")
        exit(1)
    except WeeImportMapError, e:
        wlog.printlog(syslog.LOG_INFO, "**** Unable to parse source-to-weewx field map.")
        wlog.printlog(syslog.LOG_INFO, "**** %s" % e)
        print "**** Nothing done, exiting."
        wlog.logonly(syslog.LOG_INFO, "**** Nothing done.")
        exit(1)
    except (weewx.ViolatedPrecondition, weewx.UnsupportedFeature) as e:
        wlog.printlog(syslog.LOG_INFO, "**** %s" % e)
        print "**** Nothing done, exiting."
        wlog.logonly(syslog.LOG_INFO, "**** Nothing done.")
        print
        parser.print_help()
        exit(1)
    except SystemExit, e:
        print e
        exit(0)
    except (ValueError, weewx.UnitError) as e:
        wlog.printlog(syslog.LOG_INFO, "**** %s" % e)
        print "**** Nothing done, exiting."
        wlog.logonly(syslog.LOG_INFO, "**** Nothing done.")
        exit(1)
    except IOError, e:
        wlog.printlog(syslog.LOG_INFO, "**** Unable to load config file.")
        wlog.printlog(syslog.LOG_INFO, "**** %s" % e)
        print "**** Nothing done, exiting."
        wlog.logonly(syslog.LOG_INFO, "**** Nothing done.")
        exit(1)

# ============================================================================
#                           wee_import Error Classes
# ============================================================================


class WeeImportMapError(Exception):
    """Base class of exceptions thrown when encountering an error with an
       external source-to-weewx field map.
    """


class WeeImportIOError(Exception):
    """Base class of exceptions thrown when encountering an I/O error with an
       external source.
    """


class WeeImportFieldError(Exception):
    """Base class of exceptions thrown when encountering an error with a field
       from an external source.
    """

# ============================================================================
#                              class WeeImportLog
# ============================================================================


class WeeImportLog(object):
    """Class to handle wee_import logging.

    This class provides a wrapper around the python syslog module to handle
    wee_import logging requirements.
    """

    def __init__(self, log_facy, verbose, dry_run):
        """Initialise our syslog environment."""

        # Flag to indicate whether we are logging to file or not. Logging
        # during a dry run would be too confusing and of little overall value
        # but if not a dry run and if we have a file name then log
        self.log = not dry_run and (False if log_facy is None else True)
        # syslog log facility to be used
        self.log_facy = log_facy
        # if we are logging then setup our syslog environment
        # if --verbose we log up to syslog.LOG_DEBUG
        # otherwise just log up to syslog.LOG_INFO
        if self.log:
            syslog.openlog(log_facy, syslog.LOG_PID | syslog.LOG_CONS)
            if verbose:
                syslog.setlogmask(syslog.LOG_UPTO(syslog.LOG_DEBUG))
            else:
                syslog.setlogmask(syslog.LOG_UPTO(syslog.LOG_INFO))
        # logging by other modules (eg WxCalculate) does not use WeeImportLog
        # but we can disable most logging by raising the log priority if its a
        # dry run
        if dry_run:
            syslog.setlogmask(syslog.LOG_UPTO(syslog.LOG_CRIT))

    def logonly(self, level, message):
        """Log to syslog only."""

        # are we logging ?
        if self.log:
            # add a little preamble to say this is wee_import
            _message = 'wee_import: ' + message
            syslog.syslog(level, _message)

    def printlog(self, level, message):
        """Print to screen and log to syslog."""

        print message
        self.logonly(level, message)

    def verboselog(self, level, message, verbose):
        """Print to screen if --verbose and log to syslog always."""

        if verbose:
            print message
            self.logonly(level, message)

# ============================================================================
#                                class Source
# ============================================================================


class Source(object):
    """ Abstract base class used for interacting with an external data source
        to import records into the weewx archive.

    Child classes must define a getRawData() method which:
    -   gets the raw observation data and returns an iterable yielding data
        dicts whose fields can be mapped to a weewx archive field.
    -   defines an import data field-to-weewx archive field map (self.map).

    __init__() must also define the following properties:
        self.dry_run      - Is this a dry run (ie do not save imported records
                            to archive). [True|False]
        self.calc_missing - Calculate any missing derived observations.
                            [True|False]
        self.tranche      - Number of records to be written to archive in a
                            single transaction. Integer
        self.interval     - Method of determining interval value if interval
                            field not included in data source.
                            ['config'|'derive']
        self.raw_datetime_format - Format of date time data field from which
                                   observation timestamp is to be derived. A
                                   string in Python datetime string format such
                                   as '%Y-%m-%d %H:%M:%S'. If the date time
                                   data field cannot be intrepreted as a string
                                   wee_import attempts to interpret the field
                                   as a unix timestamp. If the field is not a
                                   valid unix timestamp an error is raised.
    """

    # reg expression to match any HTML tag of the form <...>
    _tags = re.compile(r'\<.*\>')

    def __init__(self, config_dict, import_config_dict, options):
        """A generic initialisation.

        Set some realistic default values for tranche, interval and
        raw_datetime_format. Obtain altitude, latitude, longitude and a
        database manager object so that a WXCalculate object can be created to
        handle adding any missing derived observations to the imported records.
        """

        # tell our user (and more importantly the logs) that we are starting
        # wee_import before any other 'housekeeping' messages are printed/logged.
        wlog.printlog(syslog.LOG_INFO, "Starting wee_import...")

        # save our weewx config dict
        self.config_dict = config_dict

        # get our 'interval' setting from our import config dict, default to
        # 'derive'
        self.interval = import_config_dict.get('interval', 'derive')
        # get our 'tranche' setting from our import config dict, default to 250
        self.tranche = to_int(import_config_dict.get('tranche', 250))

        # set some properties based on our command line options
        self.dry_run = options.dry_run
        self.calc_missing = options.calc_missing
        self.verbose = options.verbose

        # parameters required to obtain a WXCalculate object
        stn_dict = config_dict['Station']
        altitude_t = option_as_list(stn_dict.get('altitude', (None, None)))
        try:
            altitude_vt = weewx.units.ValueTuple(float(altitude_t[0]),
                                                 altitude_t[1],
                                                 "group_altitude")
        except KeyError, e:
            raise weewx.ViolatedPrecondition(
                "Value 'altitude' needs a unit (%s)" % e)
        latitude_f = float(stn_dict['latitude'])
        longitude_f = float(stn_dict['longitude'])
        # get some weewx database info
        self.db_binding_wx = get_binding(config_dict)
        self.dbm = open_manager_with_config(config_dict, self.db_binding_wx,
                                            initialize=True,
                                            default_binding_dict={'table_name': 'archive',
                                                                  'manager': 'weewx.wxmanager.WXDaySummaryManager',
                                                                  'schema': 'schemas.wview.schema'})
        # get a WXCalculate object
        self.wxcalculate = weewx.wxservices.WXCalculate(config_dict,
                                                        altitude_vt,
                                                        latitude_f,
                                                        longitude_f)

        # initialise a few properties we will need during the import
        # answer flags
        self.ans = None
        self.interval_ans = None
        # properties to help with processing multi-period imports
        self.first_period = True
        self.last_period = False
        self.period_no = 1

        # if a --date command line option was used then we need to determine
        # the time span over which we will import any records. We will import
        # records that have dateTime > self.first_ts and <=self.last_ts.
        if options.date:
            # do we have a date range or a single date only - look for the '-'
            dates = options.date.split('-', 1)
            if len(dates) > 1:
                # we have a range
                # first try to get a date and time for each
                try:
                    _first = dt.strptime(dates[0], "%Y/%m/%d %H:%M")
                    _first_tt = _first.timetuple()
                    _last = dt.strptime(dates[1], "%Y/%m/%d %H:%M")
                    _last_tt = _last.timetuple()
                    self.first_ts = time.mktime(_first_tt)
                    self.last_ts = time.mktime(_last_tt)
                except ValueError:
                    # that did not work so try to get a date for each
                    try:
                        _first = dt.strptime(dates[0], "%Y/%m/%d")
                        _first_tt = _first.timetuple()
                        _last = dt.strptime(dates[1], "%Y/%m/%d") + datetime.timedelta(days=1)
                        _last_tt = _last.timetuple()
                        self.first_ts = time.mktime(_first_tt)
                        self.last_ts = time.mktime(_last_tt)
                    except:
                        _msg = "Cannot parse --date argument '%s'." % options.date
                        raise ValueError(_msg)
            else:
                # we have a date
                _first_dt = dt.strptime(dates[0], "%Y/%m/%d")
                _first_tt = _first_dt.timetuple()
                _last_dt = _first_dt + datetime.timedelta(days=1)
                _last_tt = _last_dt.timetuple()
                self.first_ts = time.mktime(_first_tt)
                self.last_ts = time.mktime(_last_tt)
        else:
            # no date on the command line so set our first/last ts to None
            self.first_ts = None
            self.last_ts = None

        # total records processed
        self.total_rec_proc = 0
        # total unique records identified
        self.total_unique_rec = 0
        # unit system of our archive
        self.archive_unit_sys = None
        # time we started to first save
        self.t1 = None

    @staticmethod
    def sourceFactory(options, args):
        """Factory to produce a Source object.

        Returns an appropriate object depending on the source type. Raises a
        weewx.UnsupportedFeature error if an object could not be created.
        """

        # get some key weewx parameters
        # first the config dict to use
        config_path, config_dict = weecfg.read_config(None,
                                                      args,
                                                      file_name=options.config_path)
        # get wee_import config dict if it exists
        import_config_path, import_config_dict = weecfg.read_config(None,
                                                                    args,
                                                                    file_name=options.import_config_path)
        # now create our object
        if options.csv:
            # return a CSVSource object
            return CSVSource(config_dict,
                             config_path,
                             import_config_dict.get('CSV', {}),
                             import_config_path,
                             options)
        elif options.wunder:
            # return a WunderSource object
            return WunderSource(config_dict,
                                config_path,
                                import_config_dict.get('Wunderground', {}),
                                import_config_path,
                                options)
        elif options.cumulus:
            # return a WunderSource object
            return CumulusSource(config_dict,
                                 config_path,
                                 import_config_dict.get('Cumulus', {}),
                                 import_config_path,
                                 options)
        else:
            # was asked for something I don't know how to manufacture so raise
            # an error
            raise weewx.UnsupportedFeature(
                "No option specified or requested option not yet implemented.")

    def run(self):
        """Main entry point for importing from an external source.

        Source data may be provided as a group of records over a single period
        (eg a single CSV file) or as a number of groups of records covering
        multiple periods(eg a WU multi-day import). Step through each group of
        records, getting the raw data, mapping the data and saving the data for
        each period.
        """

        # setup a counter to count the periods of records
        self.period_no = 1
        with self.dbm as archive:
            # step through our periods of records until we reach the end. A
            # 'period' of records may comprise the contents of a file, a day
            # of WU obs or a month of Cumulus obs
            for period in self.period_generator():

                # get the raw data
                _msg = 'Obtaining raw import data for period %d...' % self.period_no
                wlog.verboselog(syslog.LOG_INFO, _msg, self.verbose)
                _raw_data = self.getRawData(period)
                _msg = 'Raw import data read successfully for period %d.' % self.period_no
                wlog.verboselog(syslog.LOG_INFO, _msg, self.verbose)

                # map the raw data to a weewx archive compatible dictionary
                _msg = 'Mapping raw import data for period %d...' % self.period_no
                wlog.verboselog(syslog.LOG_INFO, _msg, self.verbose)
                _mapped_data = self.mapRawData(_raw_data, weewx.US)
                _msg = 'Raw import data mapped sucessfully for period %d.' % self.period_no
                wlog.verboselog(syslog.LOG_INFO, _msg, self.verbose)

                # save the mapped data to archive
                _msg = 'Saving mapped data to archive for period %d...' % self.period_no
                wlog.verboselog(syslog.LOG_INFO, _msg, self.verbose)
                self.saveToArchive(archive, _mapped_data)
                _msg = 'Mapped data saved to archive successfully for period %d.' % self.period_no
                wlog.verboselog(syslog.LOG_INFO, _msg, self.verbose)

                # increment our period counter
                self.period_no += 1

    def parseMap(self, source_type, source, import_config_dict):
        """Produce a source field-to-weewx archive field data map.

        Data from an external source can be mapped to the weewx archive using a
        fixed map (WU) or through a user defined map in the wee_import conf file.
        First look for a map in the wee_import conf file, if the map is valid
        then return it. If the map is not valid or not found then return the
        default map.

        Input parameters:

            source_type: String holding name of the stanza in
                         import_config_dict holding the config details for the
                         source being used.

            source: Iterable holding the source data. Used if something like
                    import field names are included in the source data (eg CSV).

            import_config_dict: wee_import config dict.

        Returns a map as a dictionary of elements with each element structured
        as follows:

            'archive_name': {'name': 'field_name', 'units': 'unit_name'}

            where:

                archive_name is an observation name in the weewx database
                schema
                field_name is the name of a field from the external source
                unit_name is the name of the units, as defined in weewx, used
                by field_name
        """

        # start with the minimum map
        _map = dict(MINIMUM_MAP)
        # Look for a mapping for source in our config dict otherwise use the
        # default.
        # do we have a [source_type] stanza?
        if 'Map' in import_config_dict:
            # we have a wee_import.conf map so lets get it
            for _field in import_config_dict['Map']:
                _entry = option_as_list(import_config_dict['Map'][_field])
                # expect 2 parameters for each option
                if len(_entry) == 2:
                    # we have 2 parameter so that's name and units
                    _map[_field] = {'name': _entry[0], 'units': _entry[1]}
                # if the entry is not empty then it might be valid
                elif _entry != [''] and len(_entry) == 1:
                    # we have 1 parameter so it must be just name
                    _map[_field] = {'name': _entry[0]}
                else:
                    # otherwise its invalid so ignore it
                    pass
            # Do some crude error checking.
            # we must have a dateTime entry
            if _map['dateTime'] is not None:
                # do we have a unit system specified (ie a 'usUnits' entry)
                if 'usUnits' not in _map:
                    # no unit system mapping do we have units specified for
                    # each individual field
                    for _field in _map:
                        if _field not in ['dateTime', 'usUnits']:
                            if 'units' in _map[_field]:
                                # we have a units field, do we know about it
                                if _map[_field]['units'] not in weewx.units.default_unit_format_dict:
                                    # we have an invalid unit string so tell
                                    # the user and exit
                                    raise weewx.UnitError(
                                        "Unknown units '%s' specified for field '%s' in %s." % (_map[_field]['units'],
                                                                                                _field,
                                                                                                self.import_config_path))
            else:
                # no dateTime map so tell the user and exit
                raise WeeImportMapError(
                    "'%s' field map found but no mapping specified for field 'dateTime'." % source_type)
            # if we got this far we have a usable map, advise the user what we
            # will use
            _msg = "The following imported field-to-weewx field map will be used:"
            if self.verbose:
                wlog.verboselog(syslog.LOG_INFO, _msg, self.verbose)
            else:
                wlog.logonly(syslog.LOG_INFO, _msg)
            for key, entry in _map.iteritems():
                _units_msg = ""
                if 'units' in entry:
                    _units_msg = " in units '%s'" % entry['units']
                _msg = "     import field '%s'%s --> weewx field '%s'" % (key,
                                                                          _units_msg,
                                                                          entry['name'])
                if self.verbose:
                    wlog.verboselog(syslog.LOG_INFO, _msg, self.verbose)
                else:
                    wlog.logonly(syslog.LOG_INFO, _msg)
        elif self._header_map:
            # We have a static map that maps header fields to weewx (eg WU).
            # Step through each field name in our data.
            for _key in source.fieldnames:
                # if we know about the field name add it to our map
                if _key in self._header_map:
                    _map[self._header_map[_key]['map_to']] = {'name': _key,
                                                              'units': self._header_map[_key]['units']}
        else:
            # no [[Map]] stanza and no _header_map so raise an error as we
            # don't know what to map
            _msg = "No '%s' field map found in %s." % (source_type,
                                                       self.import_config_path)
            raise WeeImportMapError(_msg)
        return _map

    def mapRawData(self, data, unit_sys=weewx.US):
        """Maps raw data to weewx archive record compatible dictionaries.

        Takes an iterable source of raw data observations, maps the fields of
        each row to a list of weewx compatible archive records and performs any
        necessary unit conversion.

        Input parameters:

            data: iterable that yields the data records to be processed.

            unit_sys: weewx unit system in which the generated records will be
                      provided. Omission will result in US customary (weewx.US)
                      being used.

        Returns a list of dicts of weewx compatible archive records.
        """

        # initialise our list of mapped records
        _records = []
        # initialise some rain variables
        _last_ts = None
        _last_rain = None
        # list of fields we have given the user a warning over, prevents us
        # giving multiple warnings for the same field.
        _warned = []
        # step through each row in our data
        for _row in data:
            _rec = {}
            # First off process the fields that require special processing
            # dateTime
            if 'name' in self.map['dateTime']:
                # we have a map for dateTime
                try:
                    _raw_dateTime = _row[self.map['dateTime']['name']]
                except:
                    raise WeeImportFieldError(
                        "Field '%s' not found in source data." % self.map['dateTime']['name'])
                # now process the raw date time data
                if _raw_dateTime.isdigit():
                    # Our dateTime is a number, is it a timestamp already?
                    # Try to use it and catch the error if there is one and
                    # raise it higher.
                    try:
                        _rec_dateTime = int(_raw_dateTime)
                    except:
                        raise ValueError(
                            "Invalid '%s' field. Cannot convert '%s' to timestamp." % (self.map['dateTime']['name'],
                                                                                       _raw_dateTime))
                else:
                    # Its a string so try to parse it and catch the error
                    # if there is one and raise it higher
                    try:
                        _datetm = time.strptime(_raw_dateTime,
                                                self.raw_datetime_format)
                        _rec_dateTime = int(time.mktime(_datetm))
                    except:
                        raise ValueError(
                            "Invalid '%s' field. Cannot convert '%s' to timestamp." % (self.map['dateTime']['name'],
                                                                                       _raw_dateTime))
                # if we have a timeframe of concern does our record fall within
                # it
                if (self.first_ts is None and self.last_ts is None) or self.first_ts <= _rec_dateTime <= self.last_ts:
                    # we have no timeframe or if we do it falls within it so
                    # save the dateTime
                    _rec['dateTime'] = _rec_dateTime
                else:
                    # it is not so skip to the next record
                    continue
            else:
                # there is no mapped field for dateTime so raise an error
                raise ValueError("No mapping for weewx field 'dateTime'.")
            # usUnits
            _units = None
            if 'name' in self.map['usUnits']:
                # we have a field map for a unit system
                try:
                    # The mapped field is in _row so try to get the raw data.
                    # If its not there then raise an error.
                    _raw_units = int(_row[self.map['usUnits']['name']])
                except:
                    _msg = "Field '%s' not found in source data." % self.map['usUnits']['name']
                    raise WeeImportFieldError(_msg)
                # we have a value but is it valid
                if _raw_units in weewx.units.unit_nicknames:
                    # it is valid so use it
                    _units = _raw_units
                else:
                    # the units value is not valid so raise an error
                    _msg = "Invalid unit system '%s'(0x%02x) mapped from data source. Check data source or field mapping." % (_raw_units,
                                                                                                                              _raw_units)
                    raise weewx.UnitError(_msg)
            # interval
            if 'name' in self.map['interval']:
                # We have a map for interval so try to get the raw data. If
                # its not there then raise an error.
                try:
                    _tfield = _row[self.map['interval']['name']]
                except:
                    raise WeeImportFieldError(
                        "Field '%s' not found in source data." % self.map['interval']['name'])
                # now process the raw interval data
                if _tfield is not None and _tfield != '':
                    try:
                        interval = int(_tfield)
                    except:
                        raise ValueError(
                            "Invalid '%s' field. Cannot convert '%s' to an integer." % (self.map['interval']['name'],
                                                                                        _tfield))
                else:
                    # if it happens to be None then raise an error
                    raise ValueError("Invalid value '%s' for mapped field '%s' at timestamp '%s'." % (_tfield,
                                                                                                      self.map['interval']['name'],
                                                                                                      timestamp_to_string(_rec['dateTime'])))
            else:
                # We have no mapping so try to calculate it
                interval = self.getInterval(_last_ts, _rec['dateTime'])
            _rec['interval'] = interval
            # now step through the rest of the fields in our map and process
            # the fields that don't require special processing
            for _field in self.map:
                # skip those that have had special processing
                if _field in MINIMUM_MAP:
                    continue
                # process everything else
                else:
                    # is our mapped field in the record
                    if self.map[_field]['name'] in _row:
                        # Yes it is. Try to get a value for the obs but
                        # if we can't catch the error
                        try:
                            _temp = float(_row[self.map[_field]['name']].strip())
                        except:
                            # perhaps we have a blank/empty entry
                            if _row[self.map[_field]['name']].strip() == '':
                                # if so we will use None
                                _temp = None
                            else:
                                # otherwise we will raise an error
                                _msg = "%s: cannot convert '%s' to float at timestamp '%s'." % (_field,
                                                                                                _row[self.map[_field]['name']],
                                                                                                timestamp_to_string(_rec['dateTime']))
                                raise ValueError(_msg)
                        # if our imported 'rain' field is cumulative
                        # (self.rain == 'cumulative') then we need to calculate
                        # the discrete rainfall for this archive period
                        if _field == "rain" and self.rain == "cumulative":
                            _rain = self.getRain(_last_rain, _temp)
                            _last_rain = _temp
                            _temp = _rain
                        # check any wind direction fields are within our
                        # bounds and convert to 0 to 360 range
                        if _field == "windDir" or _field == "windGustDir":
                            if self.wind_dir[0] <= _temp <= self.wind_dir[1]:
                                # normalise to 0 to 360
                                _temp %= 360
                            else:
                                # outside our bounds so set to None
                                _temp = None
                        # if no mapped field for a unit system we have to do
                        # field by field unit conversions
                        if _units is None:
                            _temp_vt = ValueTuple(_temp,
                                                  self.map[_field]['units'],
                                                  weewx.units.obs_group_dict[_field])
                            _conv_vt = convertStd(_temp_vt, unit_sys)
                            _rec[_field] = _conv_vt.value
                        else:
                            # we do have a mapped field for a unit system so
                            # save the field in our record and continue, any
                            # unit conversion will be done in bulk later
                            _rec[_field] = _temp
                    else:
                        # No it's not. Set the field in our output to None
                        _rec[_field] = None
                        # now warn the user about this field if we have not
                        # already done so
                        if self.map[_field]['name'] not in _warned:
                            _msg = "Warning: Import field '%s' is mapped to weewx field '%s'" % (self.map[_field]['name'],
                                                                                                 _field)
                            wlog.printlog(syslog.LOG_INFO, _msg)
                            _msg = "         but the import field could not be found."
                            wlog.printlog(syslog.LOG_INFO, _msg)
                            _msg = "         weewx field '%s' will be set to 'None'." % _field
                            wlog.printlog(syslog.LOG_INFO, _msg)
                            # make sure we do this warning once only
                            _warned.append(self.map[_field]['name'])
            # if we have a mapped field for a unit system with a valid value,
            # then all we need do is set 'usUnits', bulk conversion is taken
            # care of by saveToArchive()
            if _units is not None:
                # we have a mapped field for a unit system with a valid value
                _rec['usUnits'] = _units
            else:
                # no mapped field for unit system but we have already converted
                # any necessary fileds on a field by field basis so all we need
                # do is set 'usUnits', any bulk conversion will be taken care of
                # by saveToArchive()
                _rec['usUnits'] = unit_sys
            # If interval is being derived from record timestamps our first
            # record will have an interval of None. In this case we wait until
            # we have the second record and then we use the interval between
            # records 1 and 2 as the interval for record 1.
            if len(_records) == 1 and _records[0]['interval'] is None:
                _records[0]['interval'] = _rec['interval']
            _last_ts = _rec['dateTime']
            # this record is done, add it to our list of records to return
            _records.append(_rec)
        # If we have more than 1 unique value for interval in our records it
        # could be a sign of missing data and impact the integrity of our data,
        # so do the check and see if the user whats to continue
        if len(_records) > 0:
            # if we have any records to return do the unique interval check
            # before we return the records
            _start_interval = _records[0]['interval']
            _diff_interval = False
            for _rec in _records:
                if _rec['interval'] != _start_interval:
                    _diff_interval = True
                    break
            if _diff_interval and self.interval_ans != 'y':
                # we had more than one unique value for interval, warn the user
                wlog.printlog(syslog.LOG_INFO, "Warning: Records to be imported contain multiple different 'interval' values.")
                print "         This may mean the imported data is missing some records and it may lead"
                print "         to data integrity issues. If the raw data has a known, fixed interval value"
                print "         setting the relevant 'interval' setting in wee_import config to this value"
                print "         may give a better result."
                while self.interval_ans not in ['y', 'n']:
                    self.interval_ans = raw_input('Are you sure you want to proceed (y/n)? ')
                if self.interval_ans == 'n':
                    # the user chose to abort, but we may have already
                    # processed some records. So log it then raise a SystemExit()
                    if self.dry_run:
                        print "Dry run import aborted by user. %d records were processed." % self.total_rec_proc
                        wlog.logonly(syslog.LOG_INFO, 'User chose to abort import. Exiting. Nothing done.')
                        raise SystemExit('Exiting. Nothing done.')
                    else:
                        print "Whilst %d records were processed those with a timestamp already in the archive" % self.total_rec_proc
                        print "will not have been imported. Confirm successful import in syslog or weewx log file."
                        _msg = "User chose to abort import. %d records were processed. Exiting." % self.total_rec_proc
                        wlog.logonly(syslog.LOG_INFO, _msg)
                        if self.total_rec_proc > 0:
                            print "As the import was aborted before completion refer to the syslog or weewx log"
                            print "file to confirm which records were imported."
                            raise SystemExit('Exiting.')
                        raise SystemExit('Exiting. Nothing done.')
            wlog.verboselog(syslog.LOG_INFO,
                            "Mapped %d records." % len(_records),
                            self.verbose)
            # the user wants to continue or we have only one unique value for
            # interval so return the records
            return _records
        else:
            wlog.verboselog(syslog.LOG_INFO,
                            "Mapped 0 records.",
                            self.verbose)
            # we have no records to return so return None
            return None

    def getInterval(self, last_ts, current_ts):
        """Determine an interval value for a record.

        The interval field can be determined in one of the following ways:

        -   Derived from the raw data. The interval is calculated as the
            difference between the timestamps of consecutive records rounded to
            the nearest minute. In this case interval can change between
            records if the records are not evenly spaced in time or if there
            are missing records. This method is the default and is used when
            the interval parameter in wee_import.conf is 'derive'.

        -   Read from weewx.conf. The interval value is read from the
            archive_interval parameter in [StdArchive] in weewx.conf. In this
            case interval may or may not be the same as the difference in time
            between consecutive records. This method may be of use when the
            import source has a known interval but may be misisng a number of
            records which makes deriving the itnerval from the imported data
            problematic. This method is used when the interval parameter in
            wee_import.conf is 'conf'.

        Input paramters:

            last_ts. timestamp of the previous record.
            current_rain. timestamp of the current record.

        Returns the interval (in minutes) for the current record.
        """

        # did we have a number specified in wee_import.conf, if so use that
        try:
            return float(self.interval)
        except:
            pass
        # how are we getting interval
        if self.interval.lower() == 'conf':
            # get interval from weewx.conf
            return to_int(float(self.config_dict['StdArchive'].get('archive_interval')) / 60.0)
        elif self.interval.lower() == 'derive':
            # get interval from the timestamps of consecutive records
            try:
                _interval = int((current_ts - last_ts) / 60.0)
                # but if _interval < 0 our records are not in date time order
                if _interval < 0:
                    # so raise an error
                    _msg = "Cannot derive 'interval' for record timestamp: %s." % timestamp_to_string(current_ts)
                    wlog.printlog(syslog.LOG_INFO, _msg)
                    raise ValueError("Raw data is not in ascending date time order.")
            except TypeError:
                _interval = None
            return _interval
        else:
            # we don't know what to do so raise an error
            _msg = "Cannot derive 'interval'. Unknown 'interval' setting in %s." % self.import_config_path
            raise ValueError(_msg)

    @staticmethod
    def getRain(last_rain, current_rain):
        """Determine the rainfall in a period from two cumulative rainfall
            values.

        If the data source provides rainfall as a cumulative value then the
        rainfall in a period is the simple difference between the two values.
        But we need to take into account some special cases:

        No last_rain value. Will occur for very first record or maybe in an
                            error condition. Need to return 0.0.
        last_rain > current_rain. Occurs when rain counter was reset (maybe
                                  daily or some other period). Need to return
                                  current_rain.

        Input paramters:

            last_rain. Previous rainfall total.
            current_rain. Current rainfall total.

        Returns the rainfall in the period.
        """

        if last_rain is not None:
            # we have a value for the previous period
            if current_rain >= last_rain:
                # just return the difference
                return current_rain - last_rain
            else:
                # we are at at a cumulative reset point so we just want
                # current_rain
                return current_rain
        else:
            # we have no previous rain value so return zero
            return 0.0

    def calcMissing(self, record):
        """ Add missing observations to a record.

        If --calc_missing was used on the command line then add any missing
        derived observations (ie observation is missing or None) to the
        imported record. The weewx WxCalculate class is used to add any missing
        observations.

        Input parameters:

            record: A weewx compatble archive record.

        Returns a weewx compatible archive record that includes any derived
        observations that were previously missing/None.
        """

        if self.calc_missing:
            self.wxcalculate.do_calculations(record, 'archive')
        return record

    def saveToArchive(self, archive, records):
        """ Save records to the weewx archive.

        Supports saving one or more records to archive. Each collection of
        records is processed and saved to archive in transactions of
        self.tranche records at a time.

        Uses weewx API addRecord() method to add archive records. No change is
        made to the daily summaries so these will need to be rebuilt if any
        records are imported.

        If --dry-run was set then nothing is saved to archive, only the counts
        and progress/summary messages are printed. If --dry-run was not set
        then the user is requested to confirm the import before any records are
        saved to archive.

        Input parameters:

            archive: database manager object for the weewx archive.

            records: iterable that provides weewx compatible archive records
                     (in dict form) to be written to archive
        """

        # do we have any records?
        if records and len(records) > 0:
            # we do, confirm the user actually wants to save them
            while self.ans not in ['y', 'n'] and not self.dry_run:
                if self.first_period and self.last_period:
                    # there is only 1 period
                    print "%s records identified for import." % len(records)
                else:
                    print "Records covering multiple periods have been identified for import."
                print "Proceeding will save all imported records in the weewx archive."
                self.ans = raw_input("Are you sure you want to proceed (y/n)? ")
            if self.ans == 'y' or self.dry_run:
                # we are going to save them
                # if it's our first collection of records then provide some info
                # on the import
                if self.first_period:
                    # collect the time for some stats reporting later
                    self.t1 = time.time()
                    if archive.std_unit_system is None:
                        # we have a fresh archive (ie no records) so cannot deduce
                        # the unit system in use, so go to our config_dict
                        self.archive_unit_sys = getattr(weewx,
                                                        self.config_dict['StdConvert'].get('target_unit',
                                                                                           'US'))
                    else:
                        # get our unit system from the archive
                        self.archive_unit_sys = archive.std_unit_system
                    _msg = "Destination table '%s' unit system is '%#04x' (%s)." % (archive.table_name,
                                                                                   self.archive_unit_sys,
                                                                                   weewx.units.unit_nicknames[self.archive_unit_sys])
                    wlog.printlog(syslog.LOG_DEBUG, _msg)
                    # it's convenient to give this message now
                    if self.dry_run:
                        print 'Starting dry run import, no records will added to the archive ...'
                    else:
                        print 'Starting import ...'
                # reset record counter
                nrecs = 0
                # initialise our list of records for this tranche
                _tranche = []
                # initialise a set for use in our dry run, this lets us
                # give some better stats on records imported
                unique_set = set()
                # if we are importing multiple periods of data then tell the
                # user what period we are up to
                if not (self.first_period and self.last_period):
                    print "Period %d ..." % self.period_no
                # step through each record in this period
                for _rec in records:
                    # convert our record if reqd and add any derived obs that we
                    # can to our record
                    _final_rec = self.calcMissing(weewx.units.to_std_system(_rec,
                                                                            self.archive_unit_sys))
                    # add the record to our tranche and increment our count
                    _tranche.append(_final_rec)
                    nrecs += 1
                    # if we have a full tranche then save to archive and reset
                    # the tranche
                    if len(_tranche) >= self.tranche:
                        # add the record only if it is not a dry run
                        if not self.dry_run:
                            # add the record only if it is not a dry run
                            archive.addRecord(_tranche)
                        # add our the dateTime for each record in our tranche
                        # to the dry run set
                        for _trec in _tranche:
                            unique_set.add(_trec['dateTime'])
                        # tell the user what we have done
                        _msg = "Records processed: %d; Unique records: %d; Last timestamp: %s\r" % (nrecs,
                                                                                                    len(unique_set),
                                                                                                    timestamp_to_string(_final_rec['dateTime']))
                        print >> sys.stdout, _msg,
                        sys.stdout.flush()
                        _tranche = []
                # we have processed all records but do we have any records left
                # in the tranche?
                if len(_tranche) > 0:
                    # we do so process them
                    if not self.dry_run:
                        # add the record only if it is not a dry run
                        archive.addRecord(_tranche)
                    # add our the dateTime for each record in our tranche to
                    # the dry run set
                    for _trec in _tranche:
                        unique_set.add(_trec['dateTime'])
                    # tell the user what we have done
                    _msg = "Records processed: %d; Unique records: %d; Last timestamp: %s\r" % (nrecs,
                                                                                                len(unique_set),
                                                                                                timestamp_to_string(_final_rec['dateTime']))
                    print >> sys.stdout, _msg,
                print
                sys.stdout.flush()
                # update our counts
                self.total_rec_proc += nrecs
                self.total_unique_rec += len(unique_set)
                # if this was the last period then display a suitable message
                if self.last_period:
                    tdiff = time.time() - self.t1
                    if self.dry_run:
                        print "Finished dry run import. %d records were processed and %d unique records would have been imported." % (self.total_rec_proc, self.total_unique_rec)
                    else:
                        _msg = "Finished import. %d raw records resulted in %d unique records being processed in %.2f seconds." % (self.total_rec_proc, self.total_unique_rec, tdiff)
                        wlog.printlog(syslog.LOG_INFO, _msg)
                        print 'Whilst %d unique records were processed those with a timestamp already in the archive' % (self.total_unique_rec,)
                        print 'will not have been imported. Confirm successful import in syslog or weewx log file.'
            elif self.ans == 'n':
                # user does not want to import so display a message and then
                # ask to exit
                wlog.logonly(syslog.LOG_INFO,
                             'User chose not to import records. Exiting. Nothing done.')
                raise SystemExit('Exiting. Nothing done.')
        else:
            # we have no records to import, advise the user but what we say
            # will depend if there are any more periods to import
            if self.first_period and self.last_period:
                # there was only 1 period
                _msg = 'No records identified for import.'
            else:
                # multiple periods
                _msg = 'Period %d - no records identified for import.' % self.period_no
            print _msg
            if self.last_period and self.total_rec_proc == 0:
                _msg = 'No records were identified for import. Exiting. Nothing done.'
                wlog.printlog(syslog.LOG_INFO, _msg)

# ============================================================================
#                             class CSVSource
# ============================================================================


class CSVSource(Source):
    """Class to interact with a CSV format text file.

    Handles the import of data from a CSV format data file with known field
    names.
    """

    # Define a dict to map CSV fields to weewx archive fields. For a CSV import
    # these details are specified by the user in the wee_import config file.
    _header_map = None

    def __init__(self, config_dict, config_path, csv_config_dict, import_config_path, options):

        # call our parents __init__
        super(CSVSource, self).__init__(config_dict, csv_config_dict, options)

        # save our import config path
        self.import_config_path = import_config_path
        # save our import config dict
        self.csv_config_dict = csv_config_dict

        # get a few config settings from our CSV config dict
        # string format used to decode the imported field holding our dateTime
        self.raw_datetime_format = self.csv_config_dict.get('raw_datetime_format',
                                                            '%Y-%m-%d %H:%M:%S')
        # is our rain discrete or cumulative
        self.rain = self.csv_config_dict.get('rain', 'cumulative')
        # determine valid range for imported wind direction
        _wind_direction = option_as_list(self.csv_config_dict.get('wind_direction',
                                                                  '0,360'))
        try:
            if float(_wind_direction[0]) <= float(_wind_direction[1]):
                self.wind_dir = [float(_wind_direction[0]),
                                 float(_wind_direction[1])]
            else:
                self.wind_dir = [0, 360]
        except:
            self.wind_dir = [0, 360]
        # get our source file path
        if options.source:
            self.source = options.source
        else:
            raise weewx.ViolatedPrecondition("CSV source file not specified.")

        # inititalise our import field-to-weewx archive field map
        self.map = None
        # initialise some other properties we will need
        self.start = 1
        self.end = 1
        self.increment = 1

        # tell the user/log what we intend to do
        _msg = "A CSV import from source file '%s' has been requested." % self.source
        wlog.printlog(syslog.LOG_INFO, _msg)
        _msg = "The following options will be used:"
        wlog.verboselog(syslog.LOG_DEBUG, _msg, self.verbose)
        _msg = "     config=%s, import-config=%s" % (config_path,
                                                     self.import_config_path)
        wlog.verboselog(syslog.LOG_DEBUG, _msg, self.verbose)
        _msg = "     source=%s, date=%s" % (self.source, options.date)
        wlog.verboselog(syslog.LOG_DEBUG, _msg, self.verbose)
        _msg = "     dry-run=%s, calc-missing=%s" % (self.dry_run,
                                                     self.calc_missing)
        wlog.verboselog(syslog.LOG_DEBUG, _msg, self.verbose)
        _msg = "     tranche=%s, interval=%s, date/time_string_format=%s" % (self.tranche,
                                                                             self.interval,
                                                                             self.raw_datetime_format)
        wlog.verboselog(syslog.LOG_DEBUG, _msg, self.verbose)
        _msg = "     rain=%s, wind_direction=%s" % (self.rain, self.wind_dir)
        wlog.verboselog(syslog.LOG_DEBUG, _msg, self.verbose)
        _msg = "Using database binding '%s', which is bound to database '%s'" % (self.db_binding_wx,
                                                                                 self.dbm.database_name)
        wlog.printlog(syslog.LOG_INFO, _msg)
        if self.dry_run:
            print "This is a dry run, imported data WILL NOT be saved to archive."
        else:
            print "This is NOT a dry run, imported data WILL be saved to archive."
        if self.calc_missing:
            print "Any missing derived observations WILL be calculated."
        else:
            print "Any missing derived observations WILL NOT be calculated."
        if options.date:
            print "Observations timestamped after %s and up to and" % (timestamp_to_string(self.first_ts), )
            print "including %s will be imported." % (timestamp_to_string(self.last_ts), )

    def getRawData(self, period):
        """ Obtain an iterable containing the raw data to be imported.

        Raw data is read and any clean-up/pre-processing carried out before the
        iterable is returned. In this case we will use csv.Dictreader(). The
        iterable should be of a form where the field names in the field map can
        be used to map the data to the weewx archive record format.

        Input parameters:

            period: a simple counter that is unused but retained to keep the
                    getRawData() signature the same across all classes.
        """

        # does our source exist?
        if os.path.isfile(self.source):
            with open(self.source, 'r') as f:
                _raw_data = f.readlines()
        else:
            # if it doesn't we can't go on so raise it
            raise WeeImportIOError(
                "CSV source file '%s' could not be found." % self.source)

        # just in case the data has been sourced from the web we will remove
        # any HTML tags and blank lines that may exist
        _clean_data = []
        for _row in _raw_data:
            # get rid of any HTML tags
            _line = ''.join(CSVSource._tags.split(_row))
            if _line != "\n":
                # save anything that is not a blank line
                _clean_data.append(_line)

        # create a dictionary CSV reader, using the first line as the set of keys
        _csv_reader = csv.DictReader(_clean_data)

        # finally, get our source-to-database mapping
        self.map = self.parseMap('CSV', _csv_reader, self.csv_config_dict)

        # return our CSV dict reader
        return _csv_reader

    def period_generator(self):
        """Generator function to control import processing in run() for CSV
            imports.

        Since CSV imports import from a single file this generator need only
        return a single value before it is exhausted.
        """

        yield 1

# ============================================================================
#                             class WunderStation
# ============================================================================

class WunderSource(Source):
    """Class to interact with the Weather Underground.

    Uses WXDailyHistory.asp call via http to obtain historical daily weather
    observations for a given PWS. WU uses gelocation of the requester to
    determine the units to use when providing historical PWS records. Fields
    that can be provided with multiple possible units have the units in use
    appended to the returned field name. This means that a request for a user
    in a given location for historical data from a given station may well
    return different results to the same request being made from another
    location. This requires a mechanism to both determine the units in use from
    returned data as well as mapping a number of different possible field names
    to a given weewx archive field name.
    """

    # Dict to map all possible WU field names to weewx archive field names and
    # units
    _header_map = {'Time': {'units': 'unix_epoch', 'map_to': 'dateTime'},
                   'TemperatureC': {'units': 'degree_C', 'map_to': 'outTemp'},
                   'TemperatureF': {'units': 'degree_F', 'map_to': 'outTemp'},
                   'DewpointC': {'units': 'degree_C', 'map_to': 'dewpoint'},
                   'DewpointF': {'units': 'degree_F', 'map_to': 'dewpoint'},
                   'PressurehPa': {'units': 'hPa', 'map_to': 'barometer'},
                   'PressureIn': {'units': 'inHg', 'map_to': 'barometer'},
                   'WindDirectionDegrees': {'units': 'degree_compass',
                                            'map_to': 'windDir'},
                   'WindSpeedKMH': {'units': 'km_per_hour',
                                    'map_to': 'windSpeed'},
                   'WindSpeedMPH': {'units': 'mile_per_hour',
                                    'map_to': 'windSpeed'},
                   'WindSpeedGustKMH': {'units': 'km_per_hour',
                                        'map_to': 'windGust'},
                   'WindSpeedGustMPH': {'units': 'mile_per_hour',
                                        'map_to': 'windGust'},
                   'Humidity': {'units': 'percent', 'map_to': 'outHumidity'},
                   'dailyrainMM': {'units': 'mm', 'map_to': 'rain'},
                   'dailyrainIn': {'units': 'inch', 'map_to': 'rain'},
                   'SolarRadiationWatts/m^2': {'units': 'watt_per_meter_squared',
                                               'map_to': 'radiation'}
                   }

    def __init__(self, config_dict, config_path, wunder_config_dict, import_config_path, options):

        # call our parents __init__
        super(WunderSource, self).__init__(config_dict,
                                           wunder_config_dict,
                                           options)

        # save our import config path
        self.import_config_path = import_config_path
        # save our import config dict
        self.wunder_config_dict = wunder_config_dict

        # get a few config settings from our Wunder config dict
        # save pur station name
        if options.station:
            self.station = options.station
        else:
            raise weewx.ViolatedPrecondition("No station name specified.")
        # wind dir bounds
        _wind_direction = option_as_list(wunder_config_dict.get('wind_direction',
                                                                '0,360'))
        try:
            if float(_wind_direction[0]) <= float(_wind_direction[1]):
                self.wind_dir = [float(_wind_direction[0]),
                                 float(_wind_direction[1])]
            else:
                self.wind_dir = [0, 360]
        except:
            self.wind_dir = [0, 360]

        # some properties we know because of the format of the returned WU data
        # WU returns a fixed format date-time string
        self.raw_datetime_format = '%Y-%m-%d %H:%M:%S'
        # WU only provides hourly rainfall and a daily cumulative rainfall.
        # We use the latter so force 'cumulative' for rain.
        self.rain = 'cumulative'

        # inititalise our import field-to-weewx archive field map
        self.map = None
        # For a WU import we might have to import multiple days but we can only
        # get one day at a time from WU. So our start and end properties
        # (counters) are datetime objects and our increment is a timedelta.
        # Get datetime objects for any date or date range specified on the
        # command line, if there wasn't one then default to today.
        self.start = dt.fromtimestamp(startOfDay(self.first_ts))
        self.end = dt.fromtimestamp(startOfDay(self.last_ts))
        # set our increment
        self.increment = datetime.timedelta(days=1)

        # tell the user/log what we intend to do
        _msg = "A Weather Underground import from station '%s' has been requested." % self.station
        wlog.printlog(syslog.LOG_INFO, _msg)
        _msg = "The following options will be used:"
        wlog.verboselog(syslog.LOG_DEBUG, _msg, self.verbose)
        _msg = "     config=%s, import-config=%s" % (config_path,
                                                     self.import_config_path)
        wlog.verboselog(syslog.LOG_DEBUG, _msg, self.verbose)
        _msg = "     station=%s, date=%s" % (self.station, options.date)
        wlog.verboselog(syslog.LOG_DEBUG, _msg, self.verbose)
        _msg = "     dry-run=%s, calc-missing=%s" % (self.dry_run,
                                                     self.calc_missing)
        wlog.verboselog(syslog.LOG_DEBUG, _msg, self.verbose)
        _msg = "     tranche=%s, interval=%s, wind_direction=%s" % (self.tranche,
                                                                    self.interval,
                                                                    self.wind_dir)
        wlog.verboselog(syslog.LOG_DEBUG, _msg, self.verbose)
        _msg = "Using database binding '%s', which is bound to database '%s'" % (self.db_binding_wx,
                                                                                 self.dbm.database_name)
        wlog.printlog(syslog.LOG_INFO, _msg)
        if self.dry_run:
            print "This is a dry run, imported data WILL NOT be saved to archive."
        else:
            print "This is NOT a dry run, imported data WILL be saved to archive."
        if self.calc_missing:
            print "Any missing derived observations WILL be calculated."
        else:
            print "Any missing derived observations WILL NOT be calculated."
        if options.date:
            print "Observations timestamped after %s and up to and" % (timestamp_to_string(self.first_ts), )
            print "including %s will be imported." % (timestamp_to_string(self.last_ts), )

    def getRawData(self, period):
        """Get raw observation data and construct a map from WU to weewx
            archive fields.

        Obtain raw observational data from WU using a http WXDailyHistory
        request. This raw data needs to be cleaned of unnecessary
        characters/codes and an iterable returned.

        Since WU gelocates any http request we do not know what units our WU
        data will use until we actually receive the data. A further
        complication is that WU appends the unit abbreviation to the end of the
        returned field name for fields that can have different units. So once
        we have the data have received the response we need to determine the
        units and create a dict to map the WU fields to weewx archive fields.

        Input parameters:

            period: a datetime object representing the day of WU data from
                    which raw obs data will be read.
        """

        # the date for which we want the WU data is held in a datetime object, we need to convert it to a timetuple
        date_tt = period.timetuple()
        # construct our URL using station ID and day, month, year
        _url = "http://www.wunderground.com/weatherstation/WXDailyHistory.asp?ID=%s&" \
               "month=%d&day=%d&year=%d&format=1" % (self.station,
                                                     date_tt[1],
                                                     date_tt[2],
                                                     date_tt[0])
        # hit the WU site, wrap in a try..except so we can catch any errors
        try:
            _wudata = urllib2.urlopen(_url)
        except urllib2.URLError, e:
            wlog.printlog(syslog.LOG_ERR,
                          "Unable to open Weather Underground station %s" % self.station)
            wlog.printlog(syslog.LOG_ERR, "   **** %s" % e)
            raise
        except socket.timeout, e:
            wlog.printlog(syslog.LOG_ERR,
                          "Socket timeout for Weather Underground station %s" % self.station)
            raise

        # because the data comes back with lots of HTML tags and whitespace we
        # need a bit of logic to clean it up.
        _cleanWUdata = []
        for _row in _wudata:
            # get rid of any HTML tags
            _line = ''.join(WunderSource._tags.split(_row))
            # get rid of any blank lines
            if _line != "\n":
                # save what's left
                _cleanWUdata.append(_line)

        # now create a dictionary CSV reader, the first line is used as keys to
        # the dictionary
        _reader = csv.DictReader(_cleanWUdata)
        # finally, get our database-source mapping
        self.map = self.parseMap('Wunderground', _reader,
                                 self.wunder_config_dict)
        # return our dict reader
        return _reader

    def period_generator(self):
        """Generator function yielding a sequence of datetime objects.

        This generator controls the FOR statment in the parents run() method
        that loops over the WU days to be imported. The generator yields a
        datetime object from the range of dates to be imported."""

        _period = self.start
        while _period <= self.end:
            self.first_period = _period == self.start
            self.last_period = _period >= self.end
            yield _period
            _period += self.increment

# ============================================================================
#                             class CumulusSource
# ============================================================================


class CumulusSource(Source):
    """Class to interact with a Cumulus generated monthly log files.

    Handles the import of data from Cumulus monthly log files.Cumulus stores
    observastion data in monthly log files. Each log file contains a month of
    data in CSV format. The format of the CSV data (eg field delimiter, decimal
    point character) depends upon the settings used in Cumulus.

    Data is imported from all month log files found in the source folder one
    log file at a time. Units of measure are not specified in the monthly log
    files so the units of measure must be specified in the wee_import config
    file. Whilst the Cumulus monthly log file format is well defined, some
    pre-processing of the data is required to provide data in a format the
    suitable for use in the wee_import mapping methods.
    """

    # List of field names used during import of Cumulus log files. These field
    # names are for internal wee_import use only as Cumulus monthly log files
    # do not have a header line with defined field names. Cumulus monthly log
    # field 0 and field 1 are date and time fields respectively. getRawData()
    # combines these fields to return a formatted date-time string that is later
    # converted into a unix epoch timestamp.
    _field_list = ['datetime', 'cur_out_temp', 'cur_out_hum',
                   'cur_dewpoint', 'avg_wind_speed', 'gust_wind_speed',
                   'avg_wind_bearing', 'cur_rain_rate', 'day_rain', 'cur_slp',
                   'rain_counter', 'curr_in_temp', 'cur_in_hum',
                   'lastest_wind_gust', 'cur_windchill', 'cur_heatindex',
                   'cur_uv', 'cur_solar', 'cur_et', 'annual_et',
                   'cur_app_temp', 'cur_tmax_solar', 'day_sunshine_hours',
                   'cur_wind_bearing', 'day_rain_rg11', 'midnight_rain']
    # Dict to map all possible Cumulus field names (refer _field_list) to weewx
    # archive field names and units.
    _header_map = {'datetime': {'units': 'unix_epoch', 'map_to': 'dateTime'},
                   'cur_out_temp': {'map_to': 'outTemp'},
                   'curr_in_temp': {'map_to': 'inTemp'},
                   'cur_dewpoint': {'map_to': 'dewpoint'},
                   'cur_slp': {'map_to': 'barometer'},
                   'avg_wind_bearing': {'units': 'degree_compass',
                                        'map_to': 'windDir'},
                   'avg_wind_speed': {'map_to': 'windSpeed'},
                   'cur_heatindex': {'map_to': 'heatindex'},
                   'gust_wind_speed': {'map_to': 'windGust'},
                   'cur_windchill': {'map_to': 'windchill'},
                   'cur_out_hum': {'units': 'percent', 'map_to': 'outHumidity'},
                   'cur_in_hum': {'units': 'percent', 'map_to': 'inHumidity'},
                   'midnight_rain': {'map_to': 'rain'},
                   'cur_rain_rate': {'map_to': 'rainRate'},
                   'cur_solar': {'units': 'watt_per_meter_squared',
                                 'map_to': 'radiation'},
                   'cur_uv': {'units': 'uv_index', 'map_to': 'UV'},
                   'cur_app_temp': {'map_to': 'appTemp'}
                   }

    def __init__(self, config_dict, config_path, cumulus_config_dict, import_config_path, options):

        # call our parents __init__
        super(CumulusSource, self).__init__(config_dict,
                                            cumulus_config_dict,
                                            options)

        # save our import config path
        self.import_config_path = import_config_path
        # save our import config dict
        self.cumulus_config_dict = cumulus_config_dict

        # wind dir bounds
        self.wind_dir = [0, 360]

        # Decimal separator used in monthly log files, default to decimal point
        self.decimal = cumulus_config_dict.get('decimal', '.')
        # Field delimiter used in monthly log files, default to comma
        self.delimiter = cumulus_config_dict.get('delimiter', ',')

        # We combine Cumulus date and time fields to give a fixed format
        # date-time string
        self.raw_datetime_format = '%d/%m/%y %H:%M'
        # Cumulus log files provide a number of cumulative rainfall fields. We
        # cannot use the daily rainfall as this may reset at some time of day
        # other than midnight (as required by weewx). So we use field 26, total
        # rainfall since midnight and treat it as a cumulative value.
        self.rain = 'cumulative'

        # inititalise our import field-to-weewx archive field map
        self.map = None

        # Units of measure for some obs (eg temperatures) cannot be derived from
        # the Cumulus montly log files. These units must be specified by the
        # user in wee_import.conf. Read these units and fill in the missing
        # unit data in the header map. Do some basic error checking and
        # validation, if one of the fields is missing or invalid then we need
        # to catch the error and raise it as we can't go on.
        # Temperature
        try:
            temp_u = cumulus_config_dict['Units'].get('temperature')
        except:
            _msg = "No units specified for Cumulus temperature fields in %s." % (self.import_config_path, )
            raise weewx.UnitError(_msg)
        else:
            if temp_u in weewx.units.default_unit_format_dict:
                self._header_map['cur_out_temp']['units'] = temp_u
                self._header_map['curr_in_temp']['units'] = temp_u
                self._header_map['cur_dewpoint']['units'] = temp_u
                self._header_map['cur_heatindex']['units'] = temp_u
                self._header_map['cur_windchill']['units'] = temp_u
                self._header_map['cur_app_temp']['units'] = temp_u
            else:
                _msg = "Unknown units '%s' specified for Cumulus temperature fields in %s." % (temp_u,
                                                                                               self.import_config_path)
                raise weewx.UnitError(_msg)
        # Pressure
        try:
            press_u = cumulus_config_dict['Units'].get('pressure')
        except:
            _msg = "No units specified for Cumulus pressure fields in %s." % (self.import_config_path, )
            raise weewx.UnitError(_msg)
        else:
            if press_u in ['inHg', 'mbar', 'hPa']:
                self._header_map['cur_slp']['units'] = press_u
            else:
                _msg = "Unknown units '%s' specified for Cumulus pressure fields in %s." % (press_u,
                                                                                            self.import_config_path)
                raise weewx.UnitError(_msg)
        # Rain
        try:
            rain_u = cumulus_config_dict['Units'].get('rain')
        except:
            _msg = "No units specified for Cumulus rain fields in %s." % (self.import_config_path, )
            raise weewx.UnitError(_msg)
        else:
            if rain_u in rain_units_dict:
                self._header_map['midnight_rain']['units'] = rain_u
                self._header_map['cur_rain_rate']['units'] = rain_units_dict[rain_u]

            else:
                _msg = "Unknown units '%s' specified for Cumulus rain fields in %s." % (rain_u,
                                                                                        self.import_config_path)
                raise weewx.UnitError(_msg)
        # Speed
        try:
            speed_u = cumulus_config_dict['Units'].get('speed')
        except:
            _msg = "No units specified for Cumulus speed fields in %s." % (self.import_config_path, )
            raise weewx.UnitError(_msg)
        else:
            if speed_u in weewx.units.default_unit_format_dict:
                self._header_map['avg_wind_speed']['units'] = speed_u
                self._header_map['gust_wind_speed']['units'] = speed_u
            else:
                _msg = "Unknown units '%s' specified for Cumulus speed fields in %s." % (speed_u,
                                                                                         self.import_config_path)
                raise weewx.UnitError(_msg)

        # get our source file path
        if options.source:
            self.source = options.source
        else:
            raise weewx.ViolatedPrecondition(
                "Cumulus monthly logs folder not specified.")
        # Now get a list on monthly log files sorted from oldest to newest
        month_log_list = glob.glob(self.source + '/?????log.txt')
        _temp = [(fn, fn[-9:-7], time.strptime(fn[-12:-9],'%b').tm_mon) for fn in month_log_list]
        self.log_list = [a[0] for a in sorted(_temp,
                                              key = lambda el : (el[1], el[2]))]
        if len(self.log_list) == 0:
            raise WeeImportIOError(
                "No Cumulus monthly logs found in folder '%s'." % self.source)

        # tell the user/log what we intend to do
        _msg = "An import from Cumulus monthly log files has been requested."
        wlog.printlog(syslog.LOG_INFO, _msg)
        _msg = "The following options will be used:"
        wlog.verboselog(syslog.LOG_DEBUG, _msg, self.verbose)
        _msg = "     config=%s, import-config=%s" % (config_path,
                                                     self.import_config_path)
        wlog.verboselog(syslog.LOG_DEBUG, _msg, self.verbose)
        _msg = "     source=%s, date=%s" % (self.source, options.date)
        wlog.verboselog(syslog.LOG_DEBUG, _msg, self.verbose)
        _msg = "     dry-run=%s, calc-missing=%s" % (self.dry_run,
                                                     self.calc_missing)
        wlog.verboselog(syslog.LOG_DEBUG, _msg, self.verbose)
        _msg = "     tranche=%s, interval=%s" % (self.tranche,
                                                 self.interval)
        wlog.verboselog(syslog.LOG_DEBUG, _msg, self.verbose)
        _msg = "Using database binding '%s', which is bound to database '%s'" % (self.db_binding_wx,
                                                                                 self.dbm.database_name)
        wlog.printlog(syslog.LOG_INFO, _msg)
        if self.dry_run:
            print "This is a dry run, imported data WILL NOT be saved to archive."
        else:
            print "This is NOT a dry run, imported data WILL be saved to archive."
        if self.calc_missing:
            print "Any missing derived observations WILL be calculated."
        else:
            print "Any missing derived observations WILL NOT be calculated."
        if options.date:
            print "Observations timestamped after %s and up to and" % (timestamp_to_string(self.first_ts), )
            print "including %s will be imported." % (timestamp_to_string(self.last_ts), )

    def getRawData(self, period):
        """Get raw observation data and construct a map from Cumulus monthly
            log fields to weewx archive fields.

        Obtain raw observational data from Cumulus monthly logs. This raw data
        needs to be cleaned of unnecessary characters/codes, a date-time field
        generated for each row and an iterable returned.

        Input parameters:

            period: the file name, including path, of the Cumulus monthly log
                    file from which raw obs data will be read.
        """

        # period holds the filename of the monthly log file that contains our
        # data. Does our source exist?
        if os.path.isfile(period):
            with open(period, 'r') as f:
                _raw_data = f.readlines()
        else:
            # If it doesn't we can't go on so raise it
            raise WeeImportIOError(
                "Cumulus monthly log file '%s' could not be found." % period)

        # Our raw data needs a bit of cleaning up before we can parse/map it.
        _clean_data = []
        for _row in _raw_data:
            # Make sure we have full stops as decimal points
            _line = _row.replace(self.decimal, '.')
            # Ignore any blank lines
            if _line != "\n":
                # Cumulus has separate date and time fields as the first 2
                # fields of a row. It is easier to combine them now into a
                # single date-time field that we can parse later when we map the
                # raw data.
                _datetime_line = _line.replace(self.delimiter, ' ', 1)
                # Save what's left
                _clean_data.append(_datetime_line)

        # Now create a dictionary CSV reader
        _reader = csv.DictReader(_clean_data, fieldnames=self._field_list,
                                 delimiter=self.delimiter)
        # Finally, get our database-source mapping
        self.map = self.parseMap('Cumulus', _reader, self.cumulus_config_dict)
        # Return our dict reader
        return _reader

    def period_generator(self):
        """Generator function yielding a sequence of monthly log file names.

        This generator controls the FOR statment in the parents run() method
        that loops over the monhtly log files to be imported. The generator
        yields a monthly log file name from the list of monthly log files to
        be imported until the list is exhausted. The generator also sets the
        first_period and last_period properties."""

        # Step through each of our file names
        for month in self.log_list:
            # Set flags for first period (month) and last period (month)
            self.first_period = (month == self.log_list[0])
            self.last_period = (month == self.log_list[-1])
            # Yield the file name
            yield month

# ============================================================================
#                             Utility functions
# ============================================================================

def get_binding(config_dict):
    """Get the binding for the weewx database."""

    # Extract our binding from the StdArchive section of the config file. If
    # it's missing, return None.
    if 'StdArchive' in config_dict:
        db_binding_wx = config_dict['StdArchive'].get('data_binding',
                                                      'wx_binding')
    else:
        db_binding_wx = None
    return db_binding_wx


# execute our main code
if __name__ == "__main__":
    main()
